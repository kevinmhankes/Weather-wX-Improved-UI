/*****************************************************************************
 * Copyright (c) 2016, 2017, 2018 joshua.tee@gmail.com. All rights reserved.
 *
 * Refer to the COPYING file of the official project for license.
 *****************************************************************************/

import UIKit
import Metal
import MetalKit

let MaxBuffers = 3
let ConstantBufferSize = 2048*1024

class ViewControllerNexrad: UIViewController, MTKViewDelegate { // UIwXViewController, MKMapViewDelegate,
    
    
    var device: MTLDevice! = nil
    var commandQueue: MTLCommandQueue! = nil
    var pipelineState: MTLRenderPipelineState! = nil
    var vertexBuffer: MTLBuffer! = nil
    var vertexColorBuffer: MTLBuffer! = nil
    let inflightSemaphore = DispatchSemaphore(value: MaxBuffers)
    var bufferIndex = 0
    
    var image = ObjectTouchImageView()
    //var productButton = ObjectToolbarIcon()
    //var animateButton = ObjectToolbarIcon()
    var index = 8
    var isLocal = false
    var longPressCount = 0
    var mapIndex = 0
    //var mapView = MKMapView()
    var mapShown = false
    
    var radar = UIRadarView()
    var radarsiteButton = ObjectToolbarIcon()
    var productButton = ObjectToolbarIcon()
    var siteButton = ObjectToolbarIcon()
    var animateButton = ObjectToolbarIcon()
    var timeButton = ObjectToolbarIcon()
    
    
    @objc func gesturePan(_ gestureRecognizer: UIPanGestureRecognizer) {
        let translation = gestureRecognizer.translation(in: self.view)
        //radar.x += CGFloat(translation.x)
        //radar.y -= CGFloat(translation.y)
        radar.translate(CGFloat(translation.x), CGFloat(translation.y))
        //radar.setNeedsDisplay()
    }
    
    @objc func tapGesture(_ gestureRecognizer: UITapGestureRecognizer) {
        radar.scale *= 0.5
        radar.setNeedsDisplay()
    }
    
    @objc func tapGesture(_ gestureRecognizer: UITapGestureRecognizer, double: Int) {
        //WXGLSurfaceView.doubleTap(self, oglrArr, textObj, numberOfPanes, gestureRecognizer)
        radar.scale *= 2.0
        radar.setNeedsDisplay()
        // FIXME
    }
    
    @objc func gestureLongPress(_ gestureRecognizer: UILongPressGestureRecognizer) {
        
    }
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        /*mapView.delegate = self
        UtilityMap.setupMap(mapView, RID_ARR + TDWR_RIDS_FOR_MAP, "RID_")
        let toolbar = ObjectToolbar()
        toolbar.setConfig()
        radarsiteButton = ObjectToolbarIcon(title: "RadarSite", self, #selector(radarSiteClicked(sender:)))
        productButton = ObjectToolbarIcon(title: "Product", self, #selector(productClicked(sender:)))
        let doneButton = ObjectToolbarIcon(self, .done, #selector(doneClicked))
        animateButton = ObjectToolbarIcon(self, .play, #selector(animateClicked))
        timeButton = ObjectToolbarIcon(self, nil)
        var toolbarButtons = [UIBarButtonItem]()
        toolbarButtons.append(doneButton)
        toolbarButtons.append(timeButton)
        toolbarButtons.append(flexBarButton)
        toolbarButtons.append(animateButton)
        toolbarButtons.append(productButton)
        toolbarButtons.append(radarsiteButton)
        toolbar.items = ObjectToolbarItems(toolbarButtons).items
        radarsiteButton.title = radar.ridStr
        productButton.title = radar.product
        self.view.addSubview(toolbar)
        self.view.isUserInteractionEnabled = true
        self.view.addGestureRecognizer(UIPanGestureRecognizer(target: self, action: #selector(ViewControllerNexrad.gesturePan(_:))))
        let gestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(ViewControllerNexrad.tapGesture(_:)))
        gestureRecognizer.numberOfTapsRequired = 1
        self.view.addGestureRecognizer(gestureRecognizer)
        let gestureRecognizer2 = UITapGestureRecognizer(target: self, action: #selector(ViewControllerNexrad.tapGesture(_:double:)))
        gestureRecognizer2.numberOfTapsRequired = 2
        //needed to distingish singletap/doubletap
        gestureRecognizer.require(toFail: gestureRecognizer2)
        gestureRecognizer.delaysTouchesBegan = true
        gestureRecognizer2.delaysTouchesBegan = true
        self.view.addGestureRecognizer(gestureRecognizer2)
        self.view.addGestureRecognizer(UILongPressGestureRecognizer(target: self, action: #selector(ViewControllerNexrad.gestureLongPress(_:))))
        */
        
        
        //radar.product = preferences.getString("WXOGL" + "1" + "_PROD" + "0", "N0Q")
        //radar.ridStr = preferences.getString("WXOGL" + "1" + "_RID" + "0",  Location.rid)
        //self.getContent()
        
        device = MTLCreateSystemDefaultDevice()
        guard device != nil else { // Fallback to a blank UIView, an application could also fallback to OpenGL ES here.
            print("Metal is not supported on this device")
            self.view = UIView(frame: self.view.frame)
            return
        }
        
        // setup view properties
        let view = self.view as! MTKView
        view.device = device
        view.delegate = self
        
        loadAssets()
    }
    
    func writePrefs(_ numberOfPanesInt: Int,_ indexInt: Int,_ glv: UIRadarView) {
        let numberOfPanes = String(numberOfPanesInt)
        let index = String(indexInt)
        //editor.putFloat("WXOGL" + numberOfPanes + "_ZOOM" + index, Float(glv.zoom))
        //editor.putFloat("WXOGL" + numberOfPanes + "_X" + index, glv.x)
        //editor.putFloat("WXOGL" + numberOfPanes + "_Y" + index, glv.y)
        editor.putString("WXOGL" + numberOfPanes + "_RID" + index, glv.ridStr)
        editor.putString("WXOGL" + numberOfPanes + "_PROD" + index, glv.product)
    }
    
    /*@objc override func doneClicked() {
        writePrefs(1, 0, radar)
        self.dismiss(animated: UIPreferences.backButtonAnimation, completion: {})
    }*/
    
    func updateRadarUI() {
        
        radar.removeFromSuperview()
        radar = UIRadarView(radar.product, CGRect(x: 0, y: UIPreferences.statusBarHeight, width: self.view.frame.size.width, height: self.view.frame.size.height - UIPreferences.toolbarHeight - UIPreferences.statusBarHeight))
        radar.backgroundColor = UIColor.black
        radar.isOpaque = false
        self.view.addSubview(radar)
        
    }
    
    func getContent() {
        DispatchQueue.global(qos: .userInitiated).async {
            
            //let bitmap = UtilityUSImgNWSMosaic.nwsMosaic(UtilityUSImgNWSMosaic.SECTORS[self.index])
            
            self.radar.ridPrefixGlobal = self.radar.rdDownload.getRadarFile("", self.radar.ridStr, self.radar.product, self.radar.idxStr, false)
            if !self.radar.product.contains("L2") {
                self.radar.radarBuffers.fileName = self.radar.l3BaseFn + self.radar.idxStr
            } else {
                self.radar.radarBuffers.fileName = "l2" + self.radar.idxStr
            }
            
            if ActVars.WXOGLPaneCnt == "1" {
                /*[PolygonType.STI, PolygonType.TVS, PolygonType.HI].forEach { if $0.display {self.constructLevel3TextProduct($0)}}
                 if PolygonType.SPOTTER.display {self.constructSpotters()}
                 if PolygonType.OBS.display || PolygonType.WIND_BARB.display {UtilityMetar.getStateMetarArrayForWXOGL(self.rid)}
                 if PolygonType.WIND_BARB.display  {self.constructWBLines()}
                 if PolygonType.SWO.display {
                 UtilitySWOD1.getSWO()
                 self.constructSWOLines()
                 } else {
                 self.deconstructSWOLines()
                 }*/
            }
            
            
            DispatchQueue.main.async {
                self.radarsiteButton.title = self.radar.ridStr
                self.productButton.title = self.radar.product
                self.updateRadarUI()
                //self.image.setBitmap(bitmap)
                //self.productButton.title = UtilityUSImgNWSMosaic.LABELS[self.index]
                //if !self.isLocal {editor.putInt("NWSMOSAIC_PARAM_LAST_USED", self.index)}
            }
        }
    }
    
    
    
  /*  @objc func radarSiteClicked(sender: ObjectToolbarIcon) {
        mapIndex = sender.tag
        if mapShown {
            mapView.removeFromSuperview()
            mapShown = false
        } else {
            mapShown = true
            self.view.addSubview(mapView)
        }
    }*/
    
  /*  func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {return UtilityMap.mapView(mapView, annotation)}
    
    func mapView(_ mapView: MKMapView, annotationView: MKAnnotationView,calloutAccessoryControlTapped control: UIControl) {
        mapShown = UtilityMap.mapViewExtra(mapView, annotationView, control, mapCall)
    }
    
    func mapCall(annotationView: MKAnnotationView) {self.ridChanged((annotationView.annotation!.title!)!, mapIndex)}
    */
    
    @objc func productClicked(sender: ObjectToolbarIcon) {
        let alert = ObjectPopUp(self, "Select radar product:", productButton)
        /*if WXGLNexrad.isRidTdwr(oglrArr[0].rid) {
         WXGLNexrad.radarProductListTDWR.forEach {product in
         alert.addAction(UIAlertAction(title: product, style: .default, handler: {_ in self.productChanged(sender.tag, product.split(":")[0])}))
         }
         } else {*/
        WXGLNexrad.radarProductList.forEach {product in alert.addAction(UIAlertAction(title: product, style: .default, handler: {_ in self.productChanged(sender.tag, product.split(":")[0])}))
        }
        //}
        alert.finish()
    }
    
    func productChanged(_ index: Int,_ product: String) {
        /* stopAnimate()
         oglrArr[index].product = product
         self.oglrArr[index].getRadar("")
         updateColorLegend()
         productButton.enumerated().forEach {$1.title = oglrArr[$0].product}
         getPolygonWarnings()*/
        radar.product = product
        getContent()
        //radar.setNeedsDisplay()
    }
    
    @objc func animateClicked() {
        /* if !inOglAnim {
         let alert = ObjectPopUp(self,"Select number of animation frames:", animateButton)
         ["5","10","20","30","40","50","60"].forEach {cnt in alert.addAction(UIAlertAction(title: cnt, style: .default, handler: {_ in self.animateFrameCntClicked(cnt)}))}
         alert.finish()
         } else {
         stopAnimate()
         }*/
    }
    
    func ridChanged(_ rid: String,_ index: Int) {
        /*  stopAnimate()
         UtilityFileManagement.deleteAllFiles()
         if RadarPreferences.dualpaneshareposn {
         oglrArr.forEach {changeRidInRenderer(rid, $0)}
         radarsiteButton.title = rid
         } else {
         changeRidInRenderer(rid, oglrArr[index])
         }
         if !RadarPreferences.dualpaneshareposn {siteButton.enumerated().forEach {$1.title = oglrArr[$0].rid}}
         self.view.subviews.forEach {if ($0 is UITextView) {$0.removeFromSuperview()}}
         getPolygonWarnings()
         textObj = WXGLTextObject(self, numberOfPanes, Double(view.frame.width), Double(view.frame.height), oglrArr[0], screenScale)
         textObj.initTV()
         textObj.addTV()*/
        radar.changeRid(rid)
        writePrefs(1, 0, radar)
        getContent()
    }
    
    func loadAssets() {
        
        // load any resources required for rendering
        let view = self.view as! MTKView
        commandQueue = device.makeCommandQueue()
        commandQueue.label = "main command queue"
        
        let defaultLibrary = device.makeDefaultLibrary()!
        let fragmentProgram = defaultLibrary.makeFunction(name: "passThroughFragment")!
        let vertexProgram = defaultLibrary.makeFunction(name: "passThroughVertex")!
        
        let pipelineStateDescriptor = MTLRenderPipelineDescriptor()
        pipelineStateDescriptor.vertexFunction = vertexProgram
        pipelineStateDescriptor.fragmentFunction = fragmentProgram
        pipelineStateDescriptor.colorAttachments[0].pixelFormat = view.colorPixelFormat
        pipelineStateDescriptor.sampleCount = view.sampleCount
        
        do {
            try pipelineState = device.makeRenderPipelineState(descriptor: pipelineStateDescriptor)
        } catch let error {
            print("Failed to create pipeline state, error \(error)")
        }
        
        let dataSize = vertexData.count * MemoryLayout<Float>.size
        vertexBuffer = device.makeBuffer(bytes: vertexData, length: dataSize, options: [])
        vertexBuffer.label = "vertices"
        
        vertexColorBuffer = device.makeBuffer(bytes: vertexColorData, length: dataSize, options: [])
        vertexColorBuffer.label = "colors"
    }
    
    func update() {
        
        /*
         // vData is pointer to the MTLBuffer's Float data contents
         let offset = vertexData.count * MemoryLayout<Float>.stride
         
         let pData = vertexBuffer.contents()
         let vData = (pData + offset * bufferIndex).bindMemory(to:Float.self, capacity: offset / MemoryLayout<Float>.stride)
         
         // reset the vertices to default before adding animated offsets
         vData.initialize(from: vertexData)
         
         // Animate triangle offsets
         let lastTriVertex = 24
         let vertexSize = 4
         for j in 0..<3 {
         // update the animation offsets
         xOffset[j] += xDelta[j]
         
         if(xOffset[j] >= 1.0 || xOffset[j] <= -1.0) {
         xDelta[j] = -xDelta[j]
         xOffset[j] += xDelta[j]
         }
         
         yOffset[j] += yDelta[j]
         
         if(yOffset[j] >= 1.0 || yOffset[j] <= -1.0) {
         yDelta[j] = -yDelta[j]
         yOffset[j] += yDelta[j]
         }
         
         // Update last triangle position with updated animated offsets
         let pos = lastTriVertex + j*vertexSize
         vData[pos] = xOffset[j]
         vData[pos+1] = yOffset[j]
         }
         */
    }
    
    func draw(in view: MTKView) {
        
        // use semaphore to encode 3 frames ahead
        let _ = inflightSemaphore.wait(timeout: DispatchTime.distantFuture)
        
        //    self.update()
        
        let commandBuffer = commandQueue.makeCommandBuffer()
        commandBuffer?.label = "Frame command buffer"
        
        // use completion handler to signal the semaphore when this frame is completed allowing the encoding of the next frame to proceed
        // use capture list to avoid any retain cycles if the command buffer gets retained anywhere besides this stack frame
        commandBuffer?.addCompletedHandler{ [weak self] commandBuffer in
            if let strongSelf = self {
                strongSelf.inflightSemaphore.signal()
            }
            return
        }
        
        if let renderPassDescriptor = view.currentRenderPassDescriptor, let currentDrawable = view.currentDrawable {
            let renderEncoder = commandBuffer?.makeRenderCommandEncoder(descriptor: renderPassDescriptor)
            renderEncoder?.label = "render encoder"
            
            renderEncoder?.pushDebugGroup("draw star")
            renderEncoder?.setRenderPipelineState(pipelineState)
            
            renderEncoder?.setVertexBuffer(vertexBuffer, offset: 0, index: 0)
            renderEncoder?.setVertexBuffer(vertexColorBuffer, offset:0 , index: 1)
            //      renderEncoder.setCullMode(.back)
            renderEncoder?.drawPrimitives(type: .triangle,
                                         vertexStart: 0,
                                         vertexCount: vertexData.count)
            
            renderEncoder?.popDebugGroup()
            renderEncoder?.endEncoding()
            
            commandBuffer?.present(currentDrawable)
        }
        
        // bufferIndex matches the current semaphore controled frame index to ensure writing occurs at the correct region in the vertex buffer
        bufferIndex = (bufferIndex + 1) % MaxBuffers
        
        commandBuffer?.commit()
    }
    
    
    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {
        
    }
}
